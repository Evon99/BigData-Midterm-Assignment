# 정규 표현식

1. 정의: 문자열을 처리하는 방법 중의 하나로 특정한 조건의 문자를 '검색'하거나 '치환'하는 과정을 매우 간편하게 처리 할 수 있도록 하는 수단

2. 메타문자: 문자를 설명하기 위한 문자로, 문자의 구성을 설명하기 위해 원래 그 문자가 가진 뜻이 아닌 특별한 용도로 사용하는 문자<br>
정규 표현식에서 사용하는 메타문자: . ^ $ * + ? {} [] \ | ()

3. 정규표현식의 종류 <br>
+ []: 문자 클래스인 []는 "[] 사이의 문자들과 매치"라는 의미를 가지며, []사이에는 어떤 문자도 들어갈 수 있다. <br>
[a, b, c]: "a, b, c 중 한 개의 문자와 매치" <br>
ex) [a, b, c]와 "a", "bus", "replit"와 어떻게 매치되는가?
  - "a": 정규식과 일치하는 문자인 a가 있으므로 매치
  - "bus": 정규식과 일치하는 문자인 b가 있으므로 매치
  - "replit": 정규식과 일치하는 문자인 a, b, c중 어느 하나도 포함하고 있지 않으므로 매치되지 않음
  
+ 하이픈(-), 캐럿(^): 하이픈(-)은 두 문자 사이의 범위(from - to)를 의미, 캐럿(^)은 반대를 의미 <br>
ex)
  - [a-zA-Z]: a부터 z까지 그리고 A부터 Z까지로 알파벳 모두 매치
  - [0-9]: 0부터 9까지의 범위로 숫자 매치
  - \[^0-9]: 0부터 9까지의 범위의 부정으로 숫자가 아닌 문자만 매치
    * []안에서는 부정의 의미로 사용
    * []가 없으면 문자열의 처음을 뜻함(끝은 $로 표시)

+ \역슬래쉬: [0-9]또는 [a-zA-Z]와 같은 정규표현식은 \역슬래쉬를 이용해 간단하게 표현할 수 있다.
  - \d: 숫자와 매치, [0-9]와 동일한 표현식
  - \D: 숫자가 아닌 것과 매치, [^0-9]와 동일한 표현식
  - \s: whitespace 문자와 매치, [ \t\n\r\f\v]와 동일한 표현식이다. 맨 앞의 빈 칸은 공백문자(space)를 의미
  - \S: whitespace 문자가 아닌 것과 매치, [^\t\n\r\f\v]와 동일한 표현식
  - \w: 문자+숫자(alphanumeric)와 매치, [a-zA-Z0-9_]와 동일한 표현식
  - \W: 문자+숫자(alphanumeric)가 아닌 문자와 매치, [^a-zA-Z0-9_]와 동일한 표현식
  - \b: 단어 경계 (`\w`와 `\W`의 경계)
  - \B: 비단어 경계
대문자로 사용된 것은 소문자의 반대임
정규식 상의 특별한 의미가 있는 문자들을 문자 그대로 쓸 때 앞에 붙혀 사용

+ Dot(.): 줄바꿈 문자인 \n을 제외한 모든 문자와 매치됨을 의미
ex)
  - a.b: "a + 모든문자 + b"와 같고 와b라는 문자 사이에 어떤 문자가 들어가도 모두 매치가 된다는 의미
      * "aab": 가운데 문자 a가 모든 문자를 의미하는 .과 일치하므로 정규식과 매치
      * "a0b": 동일하게 가운데 문자 0이 모든 문자를 의미하는 .과 일치하므로 정규식과 매치
      * "abc": a와 b사이에 어떤 문자가 존재하지 않기 때문에 위 정규식과 매치되지 않음
      * "a[.]b": []는 내부에 메타문자가 들어가더라도 문자 그대로 인식해주는 특징을 갖고 있습니다. 따라서 a.b와 매치되고 a0b와 같은 문자열은 매치되지 않음

+ 반복 관련 메타 문자 * + ? {}
  - 반복(\*): 메타문자 \*은 \* 바로 앞에 있는 문자가 0부터 무한대로 반복 될 수 있다는 의미 <br>
  ca*t: c + a(0번 이상 반복) + t 를 의미 -> ct, cat, caaaaat 모두 매치
  - 반복(+): 반복을 나타내는 또 다른 문자인 +, +는 *과 달리 최소 1번 이상 반복될 때 사용 <br>
  ca\*t -> ct, cat, caaat중 ct는 매치되지 않음
  - 반복({m, n}): {}는 원하는 반복 횟수를 지정할 때 사용, m에서 n까지 반복, m이상인 경우, n이하인 경우 등 자유롭게 원하는 만큼 조절 가능
      * {m}: 반드시 m번 반복
        + ca{2}t: "c + a(반드시 2번 반복) + t"
      * {m, n}: m~n회 반복
        + ca{2, 5}t: "c + a(2~5회 반복) + t"
      * {m,}, {,n}: m회 이상 반복, n회 이하 반복
  - 반복(?): ?는 반복은 아니지만 비슷한 개념으로 {0, 1}과 같은 의미를 지님. 즉, 문자가 있거나 없거나 둘 다 매치 되는 경우 뜻함
      * ab?c: "a + b(있어도 되고 없어도 된다) + c"
*, +, ?메타 문자는 모두 {m, n} 형태로 고쳐 쓰는 것이 가능하지만 가독성을 위해 *, +, ?메타 문자를 사용하는 것이 좋다.

4. 정규표현식의 예시 (이메일)
+ \w+@\w+\\.[a-zA-Z]{2,3}
  - \w+: 1개 이상의 알파벳 대소문자, 숫자, 밑줄 (_) 문자를 나타냅니다. 이메일 주소의 로컬 파트인 이메일 아이디 부분에 해당
  - @: 이메일 주소에서 "@" 기호를 나타냄.
  - \w+: 1개 이상의 알파벳 대소문자, 숫자, 밑줄 (_) 문자를 나타냅니다. 이메일 주소의 도메인 부분에 해당
  - \\.: 마침표 (.) 문자를 나타냅니다. 이메일 주소의 도메인과 최상위 도메인 사이에 위치
  - [a-zA-Z]{2,3}: 2자리 또는 3자리의 알파벳 대소문자를 나타내며 이메일 주소의 최상위 도메인에 해당 <br>
  ex) "com", "net", "edu" 등

5. 정규표현식의 필요 이유
+ 문자열 패턴 탐색: 정규표현식은 특정 패턴을 가진 문자열을 찾는 데 사용된다. 예를 들어, 이메일 주소, 전화번호 등과 같은 특정 형식의 문자열을 찾을 때 유용함. 이를 통해 데이터에서 원하는 정보를 추출하거나 유효성을 검사할 수 있음.
+ 데이터 유효성 검증: 정규표현식은 입력된 데이터가 지정된 형식에 맞는지 확인하는 데 사용된다. 예를 들어, 사용자가 입력한 이메일 주소가 올바른 형식인지, 비밀번호가 요구 조건을 충족하는지 등을 검사할 수 있음.
+ 문자열 처리 및 변환: 정규표현식은 문자열을 추출하거나 대체, 변환하는 데 유용함. 예를 들어, 특정 패턴을 가진 문자열을 추출하여 다른 형식으로 변환하거나, 공백을 제거하거나, 특정 문자를 다른 문자로 대체하는 등의 작업을 수행할 수 있음.
+ 텍스트 분석과 데이터 추출: 정규표현식을 사용하면 텍스트 데이터에서 원하는 정보를 추출할 수 있다. 예를 들어, 로그 파일에서 특정 이벤트의 발생 횟수를 세거나, 웹 스크래핑을 통해 웹 페이지에서 필요한 데이터를 추출할 때 정규표현식을 활용할 수 있음.
+ 프로그래밍 언어와 도구 지원: 많은 프로그래밍 언어와 텍스트 편집기에서는 정규표현식을 지원하며, 문자열 처리와 관련된 다양한 작업에 사용할 수 있는 함수와 도구를 제공한다. 따라서 정규표현식을 이해하고 사용하면 문자열 작업을 효율적으로 수행할 수 있음.
-> 정규표현식은 문자열 처리의 필수 도구로, 데이터 유효성 검사, 패턴 매칭, 문자열 추출 및 변환 등 다양한 작업에 활용된다. 이를 통해 코드의 효율성을 높일 수 있다.

6. 파이썬에서의 정규표현식
파이썬은 정규표현식을 지원하기위해 re(regular expression) 모듈을 제공 <br>
ex) <br>
```
import re
pattern = re.compile("정규식")  
```
re.compile을 사용하여 정규 표현식을 컴파일. re.compile의 결과인 객체 pattern에 입력한 정규식의 대한 정보가 담겨 있음

```
import re
p = re.compile('[a-z]+')
```
* 예시에 사용될 객체 p 생성
컴파일된 패턴 객체는 다음의 4가지 메소드를 제공
+ match(): 문자열의 처음부터 정규식과 매치되는지 조사, 반환값: match 객체
  - \>>> m = p.match("python") <br>
    \>>> print(m) <br>
    <_sre.SRE_Match object at 0x01F3F9F8> <br>
    "python"은 [a-z]+ 정규식에 부합되므로 match 객체를 돌려줌 <br>
    in Python, 매치 여부 확인법
    ```
    p = re.compile(정규표현식)
    m = p.match(문자열)

    if m:
      print("정규식 일치")
    else:
      print("정규식 불일치")
    ```
+ search(): 문자열 전체를 검색하여 정규식과 매치되는지 조사
  - \>>> m = p.search("python") <br>
    \>>> print(m) <br>
    <_sre.SRE_Match object at 0x01F3F9F8> <br>
    3 python 문자열은 첫번째 문자가 숫자이므로 match 메서드에서는 None을 반환함. 하지만 search 메서드는 문자열의 처음부터 검색하는 것이 아니라 문자열 전체를 검색하기 때문에 "python" 문자열과 매치돼서 match객체를 반환
+ findall(): 정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려줌
  - \>>> result = p.findall("life is too short") <br>
    \>>> print(result) <br>
    \['life', 'is', 'too', 'short'] <br>
    정규식과 일치하는 부분인 각 단어들이 반환되는 것이 확인됨
+ finditer(): 정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 돌려줌
  - finditer는 findall과 동일하지만 그 결과로 반복 가능한 객체를 돌려줌 <br>
    \>>> result = p.findall("life is too short") <br>
    \>>> print(result) <br>
    <callable_iterator object at 0x01F5E390> <br>
    \>>> for r in result: print(r) <br>
    ... <br>
    <_sre.SRE_Match object at 0x01F3F9F8> <br>
    <_sre.SRE_Match object at 0x01F3FAD8> <br>
    <_sre.SRE_Match object at 0x01F3FAA0> <br>
    <_sre.SRE_Match object at 0x01F3F9F8> <br>

   